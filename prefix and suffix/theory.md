# Префиксные и суффиксные суммы
1. Range Minimum/Maximum Query;
2. Range Sum Query;
3. Запросы на подотрезках;
## Префиксные суммы
* Отвечает на большое количество запросов о сумме на подотрезке от L до R;
* Хотим отвечать на каждый запрос за O(1);

|Index | 0      |   1  | 2    |    3 | 4     | 5     |
|-----:|--------|------|------|------|-------|-------|
|     A|  5     |     3| 6    |    -3|  2    |       |
|     B| 0      |     5|   8  |    14|    11 |  13   |

Мы по сути сдвинули индексацию на единицу, теперь массив pref имеет длину на 1 больше, чем массив a. Естественно, вычисляется такой массив полностью аналогично написанному выше циклу. И тогда искомая сумма с L по R включительно равна просто pref[R + 1] - pref[L], и особых случаев нет.

На самом деле, такое определение очень естественно выглядит при сравнении с питоновскими срезами. У нас по сути получилось pref[i] = sum(a[:i]). И сумма среза sum(a[l:r]) получается просто pref[r] - pref[l] (не забывайте, что срезы не включают правую границу, т.е. в отличие от написанного выше, тут l включительно, а r не включительно).

# Суффиксные суммы
Помимо префиксных сумм можно также рассмотреть суффиксные суммы — суммы концов, а не начал, массива. Примерно так:

>suff[n - 1] = a[n - 1]
suff[n - 2] = a[n - 2] + a[n - 1]
suff[n - 3] = a[n - 3] + a[n - 2] + a[n - 1]
...

С ними всё аналогично: их можно вычислить аналогичным циклом (только теперь цикл должен идти с конца), можно точно так же использовать для вычисления суммы на отрезке, будет особый случай R = n - 1, ну и можно еще ввести suff[n] = 0, и тогда особых случаев не будет, и будет верно, что suff[i] = sum(a[i:]).

# Префиксные/суффискные максимумы
Можно вычислять не сумму, а произведение, НОД, максимум и т.д. Например, для префиксных максимумов:
> pref[0] = a[0]
pref[1] = max(a[0], a[1])
pref[2] = max(a[0], a[1], a[2])
pref[3] = max(a[0], a[1], a[2], a[3])
...

Вычисляется такой массив, естественно, полностью аналогично: pref[i] = max(pref[i - 1], a[i]).

Вычислять максимум на отрезке (т.е. максимум от L до R) это нам не особо поможет, потому что для максимума нет аналога вычитания, мы не можем как-то «выкинуть» первые L-1 элемент, но префиксные максимумы могут быть полезны и сами по себе, если в какой-то задаче вам надо много раз считать максимум на префиксе, то вы можете их посчитать один раз заранее.

Аналогично можно считать и суффиксные максимумы, произведения, НОДы и т.д.

# Sparse table
* Используется при многочисленных запросах о минимуме на подотрезке массива;
* Алгоритм имеет сложность О(N * log2 (N)) по памяти и по времени;

Определение. Разреженная таблица — это следующий двумерный массив размера log(n×n):

```cpp
    t[k][i]=min{a[i],a[i+1],…,a[i+2^k−1]}
```

По-русски: считаем минимумы на каждом отрезке длины 2^k.

Такой массив можно посчитать за его размер, итерируясь либо по i, либо по k:
```cpp
    t[k][i]=min(t[k−1][i],t[k−1][i+2^(k−1)])
```

Имея таком массив, мы можем для любого отрезка быстро посчитать минимум на нём. Заметим, что у любого отрезка имеется два отрезка длины степени двойки, которые пересекаются, и, главное, покрывают его и только его целиком. Значит, мы можем просто взять минимум из значений, которые соответствуют этим отрезкам.

![Alt-текст](https://ru.algorithmica.org/cs/range-queries/img/sparse-table.png "Орк")

Последняя деталь: для того, чтобы константа на запрос стала настоящей, нужно научиться считать сам логарифм за константу. Для этого можно воспользоваться доступной в GCC функцией __lg. Она внутри использует инструкцию clz (“count leading zeros”), которая присутствует в большинстве современных процессоров и возвращает количество нулей до первой единицы в бинарной записи, из чего за несколько процессорных тактов можно получить нужный округленный логарифм.

```cpp
    int a[maxn], mn[logn][maxn];
int rmq(int l, int r) { // полуинтервал [l; r)
    int t = __lg(r - l);
    return min(mn[t][l], mn[t][r - (1 << t)]);
}

// Это считается где-то в первых строчках main:

memcpy(mn[0], a, sizeof a);

for (int l = 0; l < logn - 1; l++)
    for (int i = 0; i + (2 << l) <= n; i++)
        mn[l+1][i] = min(mn[l][i], mn[l][i + (1 << l)]);
```
