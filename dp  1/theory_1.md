# Ленивая динамика
Стандартный подход в динамическом программировании — создать массив для ответов на подзадачи и пройтись по нему циклом, пересчитывая неизвестные значения из известных. Однако, иногда сложно или вообще невозможно придумать такой порядок обхода, что все необходимые значения уже посчитаны.

В подобных случаях вместо циклов можно использовать подход, называемый мемоизацией: будем считать динамику рекурсивной функцией, в которой запоминается посчитанный результат и в следующий раз сразу возвращается, когда функция вызывается от тех же входных аргументов.

#### Пример:

Решим в таком стиле задачу о нахождении n-ого числа Фибоначчи.

Изначально положим все f[i] = -1f[i]=−1: это будет обозначать, что значение для соответствующего состояния еще не посчитано. Далее, положим f[0] = 0f[0]=0 и f[1] = 1f[1]=1 как базовые значения.

Теперь напишем функцию-переход, в которая просто в самом начале проверяет, было ли уже посчитано искомое значение — и если нет, то рекурсивно его считает.

```cpp
    int f[n] = {-1};
f[0] = 0;
f[1] = 1;

int g(int k) {
    if (f[k] == -1)
        f[k] = g(k - 2) + g(k - 1);
    return f[k];
}
```
Время работы так же составит O(n), так как каждое значение мы считаем только один раз, но реальное время работы будет в несколько раз больше, потому что константа на вызовы функции значительно выше, чем на простой цикл.

Также можно заметить, что в такой динамике мы гарантированно посещаем только действительно нужные состояния, что в некоторых задачах приводит к более оптимальной асимптотике.

В более общем смысле, то, что мы делаем, называется кэшированием — запоминанием и переиспользованием промежуточных результатов. Это очень распространенная концепция в программировании, и современные языки программирования — особенно поддерживают — обычно поддерживают мемоизацию как встроенную оптимизацию.

# Динамика по подотрезкам
Разберем несколько учебных задач на динамику, где состоянием является префикс или непрерывный подотрезок какого-то массива.

## Кузнечик 
Есть полоска 1×n. Кузнечик стоит на первой клетке, он может прыгать вперед на 1, 2 или 3 клетки. Сколько есть способов добраться от начальной клетки до последней?

Попытаемся придумать рекуррентную формулу — то есть вывести, как ответ для n зависит от ответа для меньших чисел.

Пусть f[k] равно количеству способов добраться от 1 клетки до клетки номер k. Попытаемся руками посчитать несколько его первых значений:

* f[1]=1 способ 
> (стоять на месте)
* f[2]=1 способ:         
> 1→2
* f[3]=2 способа:      
> 1→2→3
>  
>1→3

* f[4]=4 способа:       
> 1→2→3→4
> 
>1→3→4
>
>1→2→4
>
>1→4
* f[5]=7 способов:
> 1→2→3→4→5
> 
>1→3→4→5
>
>1→2→4→5
>
>1→4→5
>
>1→2→3→5
>
>1→3→5
>
>1→2→5

​Давайте подумаем, каким мог быть последний прыжок кузнечика в его пути до n-й клетки? Один из трёх вариантов:
* n(n−1)→n
* n(n−2)→n
* n(n−3)→n

То есть все пути до nn разбиваются на 3 группы, и причём мы знаем сколько путей в каждой группе: в первой из них ровно f[n−1] путей — столько путей идут до (n−1)-й клетки, и дальше идет еще один прыжок; аналогично, во второй и третьей группах f[n−2] и f[n−3] путей соответственно.

Просуммировав число путей во всех трёх группах, получаем:
```cpp
    f[n]=f[n−3]+f[n−2]+f[n−1]
```
```cpp
    f[0] = 1
    f[1] = 1
    f[2] = 2
    for (int i = 3; i < n; i++)
        f[i] = f[i - 3] + f[i - 2] + f[i - 1];
```
## Кузнечик с препятствиями

Немного изменим задачу: теперь некоторые из клеток закрыты, то есть нам известно про какие-то конкретные клетки, что на них кузнечик прыгать не может.

Тогда задача все еще решается такой же рекурсивной формулой, только нужно убедиться, что f[k]=0 для всех запрещенных k.

Так как нам нужно добавить в реализацию такую проверку, немного отрефакторим код, чтобы не рассматривать прыжок каждого размера по отдельности, а также будем инициализировать только f_1:
```cpp
// a -- булевый массив, свободна ли i-ая клетка

f[0] = a[0];

for (int i = 1; i < n; i++)
    for (int j = i; j > max(i - 3, 0); j--)
        // f[i] изначально заполнены нулями
        f[i] += f[j] * a[j];
```
Заметим, что такая реализация масштабируется на любую длину прыжка k. Асимптотика будет O(n*k).

Итак, как вы уже, наверное, поняли, общая идея ДП состоит в следующем.

>Первый принцип ДП: Придумаем подзадачи. Рассмотрим не только ту задачу, ответ на которую надо выводить в выходной файл, но и более мелкие, и попробуем в общем случае каждую подзадачу свести к ещё более мелкой, т.е. придумать, как ответ на каждую подзадачу выразить через ответы на более мелкие.

>Второй принцип ДП: Во-вторых, придумать такое выражение, надо посмотреть, на что может заканчиваться решение подзадачи. В буквальном смысле посмотреть, что может быть на конце решения, и попробовать в оставшейся части решения угадать решение для другой, более мелкой, подзадачи.

ДП существенно использует тот факт, что ответ на одну и ту же мелкую подзадачу будет использоваться далее несколько раз, для получения ответов на некоторые более крупные подзадачи. Это — один из основных принципов ДП, так называемый принцип перекрытия подзадач. Это именно то, что позволяет ДП работать быстрее — намного быстрее — перебора.
